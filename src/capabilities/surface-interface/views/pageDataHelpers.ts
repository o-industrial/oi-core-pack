import {
  EaCInterfaceDetails,
  EaCInterfaceGeneratedDataSlice,
  EaCInterfacePageDataAction,
  EaCInterfacePageDataType,
  EverythingAsCodeOIWorkspace,
  interfacePageDataToSchema,
  JSONSchema7,
  SurfaceInterfaceSettings,
} from '../../../.deps.ts';
import { DEFAULT_PAGE_DATA_SLICE, ensurePageDataType } from './interfaceDefaults.ts';

type CapabilityKind = 'warmQuery' | 'dataConnection' | 'childInterface' | 'schema';

const AUTO_SLICE_PREFIX: Record<CapabilityKind, string> = {
  warmQuery: 'warmQuery',
  dataConnection: 'dataConnection',
  childInterface: 'childInterface',
  schema: 'schema',
};

type ReconcileContext = {
  workspace?: EverythingAsCodeOIWorkspace;
  surfaceLookup?: string;
  interfaceLookup?: string;
  interfaceSettings?: SurfaceInterfaceSettings;
};

type DataConnectionFeatures = NonNullable<EaCInterfaceGeneratedDataSlice['DataConnection']>;
type DataConnectionHistoricSlice = NonNullable<DataConnectionFeatures['PrefetchHistoricSlice']>;
type PageDataActionWithMeta = EaCInterfacePageDataAction & {
  ComingSoon?: boolean;
  SurfaceSupport?: {
    handler: boolean;
    client: boolean;
  };
};

export function reconcileInterfacePageData(
  pageData: EaCInterfacePageDataType,
  settings: SurfaceInterfaceSettings | undefined,
  workspace?: EverythingAsCodeOIWorkspace,
  surfaceLookup?: string,
  interfaceLookup?: string,
): EaCInterfacePageDataType {
  const next = ensurePageDataType(pageData);
  const expectedKeys = new Set<string>();
  const context: ReconcileContext = {
    workspace,
    surfaceLookup,
    interfaceLookup,
    interfaceSettings: settings,
  };

  applyLookups(
    next,
    settings?.WarmQueryLookups ?? [],
    'warmQuery',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.DataConnectionLookups ?? [],
    'dataConnection',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.ChildInterfaceLookups ?? [],
    'childInterface',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.SchemaLookups ?? [],
    'schema',
    expectedKeys,
    context,
  );

  for (const [key, slice] of Object.entries(next.Generated)) {
    if (!slice) continue;
    const source = slice.SourceCapability ?? '';
    const autoGenerated = Object.values(AUTO_SLICE_PREFIX).some((prefix) =>
      source.startsWith(`${prefix}:`)
    );
    if (autoGenerated && !expectedKeys.has(key)) {
      next.Generated[key] = {
        ...slice,
        Enabled: false,
      };
    }
  }

  return next;
}

function applyLookups(
  pageData: EaCInterfacePageDataType,
  lookups: string[],
  kind: CapabilityKind,
  expectedKeys: Set<string>,
  context: ReconcileContext,
) {
  const prefix = AUTO_SLICE_PREFIX[kind];
  for (const lookup of lookups) {
    const key = `${prefix}:${lookup}`;
    expectedKeys.add(key);
    const baseSlice = buildSlice(kind, lookup, context);
    const currentSlice = pageData.Generated[key];
    pageData.Generated[key] = mergeSlices(currentSlice, baseSlice);
  }
}

function buildSlice(
  kind: CapabilityKind,
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  switch (kind) {
    case 'warmQuery':
      return buildWarmQuerySlice(lookup, context);
    case 'dataConnection':
      return buildDataConnectionSlice(lookup, context);
    case 'childInterface':
      return buildChildInterfaceSlice(lookup, context);
    case 'schema':
      return buildSchemaSlice(lookup, context);
    default:
      return cloneSlice(DEFAULT_PAGE_DATA_SLICE);
  }
}

function buildWarmQuerySlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const warmQuery = context.workspace?.WarmQueries?.[lookup];
  const details = (warmQuery as { Details?: { Name?: string; Description?: string } })?.Details;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Warm Query - ${lookup}`;
  const description = details?.Description ??
    'Data returned from the connected warm query.';
  const refreshMs = context.interfaceSettings?.RefreshMs;

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.warmQuery}:${lookup}`,
    Schema: buildWarmQuerySchema(),
    Hydration: {
      Server: true,
      Client: true,
      ...(refreshMs ? { ClientRefreshMs: refreshMs } : {}),
    },
    Actions: buildWarmQueryActions(lookup) as EaCInterfacePageDataAction[],
    Enabled: true,
    AccessMode: 'both',
  };

  return base;
}

function buildWarmQueryActions(lookup: string): PageDataActionWithMeta[] {
  const callAction: PageDataActionWithMeta = {
    Key: `warmQuery:${lookup}:call`,
    Label: 'Call warm query',
    Description: 'Execute the warm query and return the latest results.',
    Invocation: { Type: 'warmQuery', Lookup: lookup, Mode: 'both' },
    Output: buildWarmQuerySchema(),
    SurfaceSupport: { handler: true, client: true },
  };

  const statsAction: PageDataActionWithMeta = {
    Key: `warmQuery:${lookup}:stats`,
    Label: 'Warm query stats',
    Description: 'Retrieve execution statistics for the warm query.',
    Invocation: { Type: 'warmQuery', Lookup: lookup },
    ComingSoon: true,
    SurfaceSupport: { handler: true, client: true },
    Output: buildWarmQueryStatsSchema(),
  };

  return [callAction, statsAction];
}

function buildDataConnectionActions(lookup: string): PageDataActionWithMeta[] {
  const loadLast: PageDataActionWithMeta = {
    Key: `dataConnection:${lookup}:loadLast`,
    Label: 'Load last records',
    Description: 'Fetch the most recent records up to a specified count.',
    Invocation: { Type: 'dataConnection', Lookup: lookup, Mode: 'both' },
    Input: buildLoadLastInputSchema(),
    Output: buildDataConnectionSchema(),
    SurfaceSupport: { handler: true, client: true },
  };

  const download: PageDataActionWithMeta = {
    Key: `dataConnection:${lookup}:download`,
    Label: 'Download history',
    Description:
      'Generate a bulk export of records between the provided dates (CSV, JSON, JSONL).',
    Invocation: { Type: 'dataConnection', Lookup: lookup, Mode: 'client' },
    Input: buildDownloadInputSchema(),
    Output: buildHistorySchema(),
    SurfaceSupport: { handler: false, client: true },
  };

  const stream: PageDataActionWithMeta = {
    Key: `dataConnection:${lookup}:stream`,
    Label: 'Stream recent data',
    Description:
      'Open a live stream that backfills recent events and pushes new records in real time.',
    Invocation: { Type: 'dataConnection', Lookup: lookup, Mode: 'client' },
    Input: buildStreamInputSchema(),
    SurfaceSupport: { handler: false, client: true },
  };

  return [loadLast, download, stream];
}

function buildDataConnectionSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const dataConnection = context.workspace?.DataConnections?.[lookup];
  const surfaceConnSettings = context.surfaceLookup
    ? context.workspace?.Surfaces?.[context.surfaceLookup]?.DataConnections?.[lookup]
    : undefined;
  const details = (dataConnection as { Details?: { Name?: string; Description?: string } })
    ?.Details;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Data Connection - ${lookup}`;
  const description = details?.Description ??
    'Live stream of records from the connected data connection.';
  const refreshSeconds = (surfaceConnSettings as { TumblingWindowSeconds?: number } | undefined)
    ?.TumblingWindowSeconds;

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.dataConnection}:${lookup}`,
    Schema: buildDataConnectionSchema(),
    Hydration: {
      Server: true,
      Client: true,
      ...(refreshSeconds ? { ClientRefreshMs: refreshSeconds * 1000 } : {}),
    },
    Actions: buildDataConnectionActions(lookup) as EaCInterfacePageDataAction[],
    Enabled: true,
    AccessMode: 'both',
    DataConnection: {
      AllowHistoricDownload: true,
      HistoricDownloadFormats: ['json'],
      PrefetchHistoricSlice: {
        Enabled: false,
        Format: 'json',
        Mode: 'relative',
        Range: {
          Amount: 7,
          Unit: 'days',
        },
      },
    },
  };

  return base;
}

function buildChildInterfaceSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const details = context.workspace?.Interfaces?.[lookup]?.Details as
    | EaCInterfaceDetails
    | undefined;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Child Interface - ${lookup}`;
  const description = details?.Description ??
    'Embedded child interface state for composing sub-views.';

  const schema = details?.PageDataType
    ? interfacePageDataToSchema(details.PageDataType)
    : buildChildInterfaceSchema();

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.childInterface}:${lookup}`,
    Schema: schema,
    Hydration: { Server: true, Client: true },
    Actions: [
      {
        Key: `childInterface:${lookup}:hydrate`,
        Label: 'Hydrate child interface',
        Description: 'Trigger hydration for the child interface view.',
        Invocation: { Type: 'interface', Lookup: lookup, Mode: 'client' },
        SurfaceSupport: { handler: false, client: true },
      } as PageDataActionWithMeta,
    ],
    Enabled: true,
    AccessMode: 'both',
  };

  return base;
}

function buildSchemaSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const schemaEntry = context.workspace?.Schemas?.[lookup];
  const schema = schemaEntry?.Details?.Schema as JSONSchema7 | undefined;
  const label = schemaEntry?.Details?.Name?.trim()?.length
    ? schemaEntry.Details.Name.trim()
    : `Schema - ${lookup}`;
  const description = schemaEntry?.Details?.Description ??
    'Static schema-driven data made available to this interface.';

  return {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.schema}:${lookup}`,
    Schema: schema ? cloneJsonSchema(schema) : buildSchemaFallback(),
    Hydration: { Server: true },
    Enabled: true,
    AccessMode: 'server',
  };
}

function mergeSlices(
  existing: EaCInterfaceGeneratedDataSlice | undefined,
  base: EaCInterfaceGeneratedDataSlice,
): EaCInterfaceGeneratedDataSlice {
  if (!existing) return cloneSlice(base);

  const merged: EaCInterfaceGeneratedDataSlice = {
    ...cloneSlice(base),
    ...cloneSlice(existing),
    SourceCapability: base.SourceCapability,
    Schema: existing.Schema ?? base.Schema,
    Hydration: existing.Hydration ?? base.Hydration,
    Actions: mergeActions(existing.Actions, base.Actions),
  };

  merged.AccessMode = existing.AccessMode ?? base.AccessMode;
  merged.DataConnection = mergeDataConnectionFeatures(
    existing.DataConnection,
    base.DataConnection,
  );

  return merged;
}

function mergeActions(
  existing: EaCInterfacePageDataAction[] | undefined,
  base: EaCInterfacePageDataAction[] | undefined,
): EaCInterfacePageDataAction[] | undefined {
  if (!base || base.length === 0) {
    return existing ? cloneActions(existing) : undefined;
  }

  if (!existing || existing.length === 0) {
    return cloneActions(base);
  }

  const baseByKey = new Map(base.map((action) => [action.Key, action]));
  const merged: EaCInterfacePageDataAction[] = existing.map((action) => {
    const baseAction = baseByKey.get(action.Key);
    return {
      ...(baseAction ? cloneAction(baseAction) : {}),
      ...cloneAction(action),
    };
  });

  for (const action of base) {
    if (!existing.some((existingAction) => existingAction.Key === action.Key)) {
      merged.push(cloneAction(action));
    }
  }

  if (baseByKey.size > 0) {
    return merged.filter((action) => baseByKey.has(action.Key));
  }

  return merged;
}

function mergeDataConnectionFeatures(
  existing: EaCInterfaceGeneratedDataSlice['DataConnection'],
  base: EaCInterfaceGeneratedDataSlice['DataConnection'],
): DataConnectionFeatures | undefined {
  const existingClone = cloneDataConnectionFeatures(existing);
  const baseClone = cloneDataConnectionFeatures(base);

  if (!existingClone && !baseClone) return undefined;

  const result: DataConnectionFeatures = {};

  const allowHistoricDownload = existingClone?.AllowHistoricDownload ??
    baseClone?.AllowHistoricDownload;
  if (allowHistoricDownload !== undefined) {
    result.AllowHistoricDownload = allowHistoricDownload;
  }

  const formatsSource = existingClone?.HistoricDownloadFormats ??
    baseClone?.HistoricDownloadFormats;
  if (formatsSource && formatsSource.length > 0) {
    result.HistoricDownloadFormats = Array.from(new Set(formatsSource));
  }

  const prefetchSource = existingClone?.PrefetchHistoricSlice ??
    baseClone?.PrefetchHistoricSlice;
  if (prefetchSource) {
    result.PrefetchHistoricSlice = cloneDataConnectionHistoricSlice(prefetchSource);
  }

  return Object.keys(result).length ? result : undefined;
}

function cloneSlice(slice: EaCInterfaceGeneratedDataSlice): EaCInterfaceGeneratedDataSlice {
  return {
    ...slice,
    Schema: cloneJsonSchema(slice.Schema),
    Hydration: slice.Hydration ? { ...slice.Hydration } : undefined,
    Actions: slice.Actions ? cloneActions(slice.Actions) : undefined,
    DataConnection: cloneDataConnectionFeatures(slice.DataConnection),
  };
}

function cloneDataConnectionFeatures(
  features: EaCInterfaceGeneratedDataSlice['DataConnection'],
): DataConnectionFeatures | undefined {
  if (!features) return undefined;
  return JSON.parse(JSON.stringify(features)) as DataConnectionFeatures;
}

function cloneDataConnectionHistoricSlice(
  slice: DataConnectionHistoricSlice | undefined,
): DataConnectionHistoricSlice | undefined {
  if (!slice) return undefined;
  return JSON.parse(JSON.stringify(slice)) as DataConnectionHistoricSlice;
}

function cloneActions(actions: EaCInterfacePageDataAction[]): EaCInterfacePageDataAction[] {
  return actions.map((action) => cloneAction(action));
}

function cloneAction(action: EaCInterfacePageDataAction): EaCInterfacePageDataAction {
  return JSON.parse(JSON.stringify(action));
}

function cloneJsonSchema(schema: JSONSchema7): JSONSchema7 {
  return JSON.parse(JSON.stringify(schema)) as JSONSchema7;
}

function buildWarmQuerySchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      results: {
        type: 'array',
        description: 'Warm query rows returned from the execution.',
        items: { type: 'object', additionalProperties: true },
      },
      lastUpdated: {
        type: 'string',
        format: 'date-time',
        description: 'Timestamp of the most recent refresh.',
      },
    },
    additionalProperties: true,
  };
}

function buildWarmQueryStatsSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      refreshedAt: {
        type: 'string',
        format: 'date-time',
        description: 'Timestamp when the warm query last refreshed.',
      },
      durationMs: {
        type: 'number',
        description: 'Time in milliseconds spent executing the query.',
      },
      rowsAffected: {
        type: 'integer',
        description: 'Number of rows returned by the most recent run.',
      },
    },
    additionalProperties: true,
  };
}

function buildDataConnectionSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      records: {
        type: 'array',
        description: 'Recent records supplied by the data connection.',
        items: { type: 'object', additionalProperties: true },
      },
      lastEventId: {
        type: 'string',
        description: 'Identifier of the last processed event.',
      },
    },
    additionalProperties: true,
  };
}

function buildHistorySchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      downloadUrl: {
        type: 'string',
        format: 'uri',
        description: 'Signed URL used to download connection history.',
      },
    },
    required: ['downloadUrl'],
    additionalProperties: true,
  };
}

function buildChildInterfaceSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      state: {
        type: 'object',
        description: 'Snapshot of the child interface state.',
        additionalProperties: true,
      },
    },
    additionalProperties: true,
  };
}

function buildSchemaFallback(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      data: {
        type: 'object',
        description: 'Resolved schema payload exposed to the interface.',
        additionalProperties: true,
      },
    },
    additionalProperties: true,
  };
}

function buildLoadLastInputSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      count: {
        type: 'integer',
        minimum: 1,
        maximum: 100,
        description: 'Number of recent records to return (max 100).',
      },
    },
    required: ['count'],
    additionalProperties: false,
  };
}

function buildDownloadInputSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      startDate: {
        type: 'string',
        format: 'date-time',
        description: 'Inclusive start timestamp for the download window.',
      },
      endDate: {
        type: 'string',
        format: 'date-time',
        description: 'Exclusive end timestamp for the download window.',
      },
      format: {
        type: 'string',
        enum: ['csv', 'json', 'jsonl'],
        default: 'json',
        description: 'File format to use for the exported data.',
      },
    },
    required: ['startDate'],
    additionalProperties: false,
  };
}

function buildStreamInputSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      windowSeconds: {
        type: 'integer',
        minimum: 0,
        maximum: 3600,
        default: 60,
        description: 'Number of seconds of history to backfill when the stream connects.',
      },
    },
    additionalProperties: false,
  };
}














