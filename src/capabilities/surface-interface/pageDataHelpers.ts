import {
  EaCInterfaceDetails,
  EaCInterfaceGeneratedDataSlice,
  EaCInterfacePageDataAction,
  EaCInterfacePageDataType,
  EverythingAsCodeOIWorkspace,
  interfacePageDataToSchema,
  JSONSchema7,
  SurfaceInterfaceSettings,
} from '../../.deps.ts';
import {
  DEFAULT_PAGE_DATA_SLICE,
  DEFAULT_PAGE_DATA_SLICE_KEY,
  ensurePageDataType,
} from './interfaceDefaults.ts';

type CapabilityKind = 'warmQuery' | 'dataConnection' | 'childInterface' | 'schema';

const AUTO_SLICE_PREFIX: Record<CapabilityKind, string> = {
  warmQuery: 'warmQuery',
  dataConnection: 'dataConnection',
  childInterface: 'childInterface',
  schema: 'schema',
};

type ReconcileContext = {
  workspace?: EverythingAsCodeOIWorkspace;
  surfaceLookup?: string;
  interfaceLookup?: string;
  interfaceSettings?: SurfaceInterfaceSettings;
};

export function reconcileInterfacePageData(
  pageData: EaCInterfacePageDataType,
  settings: SurfaceInterfaceSettings | undefined,
  workspace?: EverythingAsCodeOIWorkspace,
  surfaceLookup?: string,
  interfaceLookup?: string,
): EaCInterfacePageDataType {
  const next = ensurePageDataType(pageData);
  const expectedKeys = new Set<string>([DEFAULT_PAGE_DATA_SLICE_KEY]);
  const context: ReconcileContext = {
    workspace,
    surfaceLookup,
    interfaceLookup,
    interfaceSettings: settings,
  };

  applyLookups(
    next,
    settings?.WarmQueryLookups ?? [],
    'warmQuery',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.DataConnectionLookups ?? [],
    'dataConnection',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.ChildInterfaceLookups ?? [],
    'childInterface',
    expectedKeys,
    context,
  );
  applyLookups(
    next,
    settings?.SchemaLookups ?? [],
    'schema',
    expectedKeys,
    context,
  );

  for (const [key, slice] of Object.entries(next.Generated)) {
    if (!slice) continue;
    const source = slice.SourceCapability ?? '';
    const autoGenerated = Object.values(AUTO_SLICE_PREFIX).some((prefix) =>
      source.startsWith(`${prefix}:`)
    );
    if (autoGenerated && !expectedKeys.has(key)) {
      next.Generated[key] = {
        ...slice,
        Enabled: false,
      };
    }
  }

  return next;
}

function applyLookups(
  pageData: EaCInterfacePageDataType,
  lookups: string[],
  kind: CapabilityKind,
  expectedKeys: Set<string>,
  context: ReconcileContext,
) {
  const prefix = AUTO_SLICE_PREFIX[kind];
  for (const lookup of lookups) {
    const key = `${prefix}:${lookup}`;
    expectedKeys.add(key);
    const baseSlice = buildSlice(kind, lookup, context);
    const currentSlice = pageData.Generated[key];
    pageData.Generated[key] = mergeSlices(currentSlice, baseSlice);
  }
}

function buildSlice(
  kind: CapabilityKind,
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  switch (kind) {
    case 'warmQuery':
      return buildWarmQuerySlice(lookup, context);
    case 'dataConnection':
      return buildDataConnectionSlice(lookup, context);
    case 'childInterface':
      return buildChildInterfaceSlice(lookup, context);
    case 'schema':
      return buildSchemaSlice(lookup, context);
    default:
      return cloneSlice(DEFAULT_PAGE_DATA_SLICE);
  }
}

function buildWarmQuerySlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const warmQuery = context.workspace?.WarmQueries?.[lookup];
  const details = (warmQuery as { Details?: { Name?: string; Description?: string } })?.Details;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Warm Query - ${lookup}`;
  const description = details?.Description ??
    'Data returned from the connected warm query.';
  const refreshMs = context.interfaceSettings?.RefreshMs;

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.warmQuery}:${lookup}`,
    Schema: buildWarmQuerySchema(),
    Hydration: {
      Server: true,
      Client: true,
      ...(refreshMs ? { ClientRefreshMs: refreshMs } : {}),
    },
    Actions: [
      {
        Key: `warmQuery:${lookup}:refresh`,
        Label: 'Refresh warm query',
        Description: 'Fetch the latest results from this warm query.',
        Invocation: { Type: 'warmQuery', Lookup: lookup, Mode: 'client' },
        Output: buildWarmQuerySchema(),
      },
    ],
    Enabled: true,
  };

  return base;
}

function buildDataConnectionSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const dataConnection = context.workspace?.DataConnections?.[lookup];
  const surfaceConnSettings = context.surfaceLookup
    ? context.workspace?.Surfaces?.[context.surfaceLookup]?.DataConnections?.[lookup]
    : undefined;
  const details = (dataConnection as { Details?: { Name?: string; Description?: string } })
    ?.Details;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Data Connection - ${lookup}`;
  const description = details?.Description ??
    'Live stream of records from the connected data connection.';
  const refreshSeconds = (surfaceConnSettings as { TumblingWindowSeconds?: number } | undefined)
    ?.TumblingWindowSeconds;

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.dataConnection}:${lookup}`,
    Schema: buildDataConnectionSchema(),
    Hydration: {
      Server: true,
      Client: true,
      ...(refreshSeconds ? { ClientRefreshMs: refreshSeconds * 1000 } : {}),
    },
    Actions: [
      {
        Key: `dataConnection:${lookup}:history`,
        Label: 'Download history',
        Description: 'Download historical records for this data connection.',
        Invocation: { Type: 'dataConnection', Lookup: lookup, Mode: 'server' },
        Output: buildHistorySchema(),
      },
    ],
    Enabled: true,
  };

  return base;
}

function buildChildInterfaceSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const details = context.workspace?.Interfaces?.[lookup]?.Details as
    | EaCInterfaceDetails
    | undefined;

  const label = details?.Name?.trim()?.length ? details.Name.trim() : `Child Interface - ${lookup}`;
  const description = details?.Description ??
    'Embedded child interface state for composing sub-views.';

  const schema = details?.PageDataType
    ? interfacePageDataToSchema(details.PageDataType)
    : buildChildInterfaceSchema();

  const base: EaCInterfaceGeneratedDataSlice = {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.childInterface}:${lookup}`,
    Schema: schema,
    Hydration: { Server: true, Client: true },
    Actions: [
      {
        Key: `childInterface:${lookup}:hydrate`,
        Label: 'Hydrate child interface',
        Description: 'Trigger hydration for the child interface view.',
        Invocation: { Type: 'interface', Lookup: lookup, Mode: 'client' },
      },
    ],
    Enabled: true,
  };

  return base;
}

function buildSchemaSlice(
  lookup: string,
  context: ReconcileContext,
): EaCInterfaceGeneratedDataSlice {
  const schemaEntry = context.workspace?.Schemas?.[lookup];
  const schema = schemaEntry?.Details?.Schema as JSONSchema7 | undefined;
  const label = schemaEntry?.Details?.Name?.trim()?.length
    ? schemaEntry.Details.Name.trim()
    : `Schema - ${lookup}`;
  const description = schemaEntry?.Details?.Description ??
    'Static schema-driven data made available to this interface.';

  return {
    Label: label,
    Description: description,
    SourceCapability: `${AUTO_SLICE_PREFIX.schema}:${lookup}`,
    Schema: schema ? cloneJsonSchema(schema) : buildSchemaFallback(),
    Hydration: { Server: true },
    Enabled: true,
  };
}

function mergeSlices(
  existing: EaCInterfaceGeneratedDataSlice | undefined,
  base: EaCInterfaceGeneratedDataSlice,
): EaCInterfaceGeneratedDataSlice {
  if (!existing) return cloneSlice(base);

  const merged: EaCInterfaceGeneratedDataSlice = {
    ...cloneSlice(base),
    ...cloneSlice(existing),
    SourceCapability: base.SourceCapability,
    Schema: existing.Schema ?? base.Schema,
    Hydration: existing.Hydration ?? base.Hydration,
    Actions: mergeActions(existing.Actions, base.Actions),
  };

  return merged;
}

function mergeActions(
  existing: EaCInterfacePageDataAction[] | undefined,
  base: EaCInterfacePageDataAction[] | undefined,
): EaCInterfacePageDataAction[] | undefined {
  if (!base || base.length === 0) {
    return existing ? cloneActions(existing) : undefined;
  }

  if (!existing || existing.length === 0) {
    return cloneActions(base);
  }

  const baseByKey = new Map(base.map((action) => [action.Key, action]));
  const merged: EaCInterfacePageDataAction[] = existing.map((action) => {
    const baseAction = baseByKey.get(action.Key);
    return {
      ...(baseAction ? cloneAction(baseAction) : {}),
      ...cloneAction(action),
    };
  });

  for (const action of base) {
    if (!existing.some((existingAction) => existingAction.Key === action.Key)) {
      merged.push(cloneAction(action));
    }
  }

  return merged;
}

function cloneSlice(slice: EaCInterfaceGeneratedDataSlice): EaCInterfaceGeneratedDataSlice {
  return {
    ...slice,
    Schema: cloneJsonSchema(slice.Schema),
    Hydration: slice.Hydration ? { ...slice.Hydration } : undefined,
    Actions: slice.Actions ? cloneActions(slice.Actions) : undefined,
  };
}

function cloneActions(actions: EaCInterfacePageDataAction[]): EaCInterfacePageDataAction[] {
  return actions.map((action) => cloneAction(action));
}

function cloneAction(action: EaCInterfacePageDataAction): EaCInterfacePageDataAction {
  return JSON.parse(JSON.stringify(action));
}

function cloneJsonSchema(schema: JSONSchema7): JSONSchema7 {
  return JSON.parse(JSON.stringify(schema)) as JSONSchema7;
}

function buildWarmQuerySchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      results: {
        type: 'array',
        description: 'Warm query rows returned from the execution.',
        items: { type: 'object', additionalProperties: true },
      },
      lastUpdated: {
        type: 'string',
        format: 'date-time',
        description: 'Timestamp of the most recent refresh.',
      },
    },
    additionalProperties: true,
  };
}

function buildDataConnectionSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      records: {
        type: 'array',
        description: 'Recent records supplied by the data connection.',
        items: { type: 'object', additionalProperties: true },
      },
      lastEventId: {
        type: 'string',
        description: 'Identifier of the last processed event.',
      },
    },
    additionalProperties: true,
  };
}

function buildHistorySchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      downloadUrl: {
        type: 'string',
        format: 'uri',
        description: 'Signed URL used to download connection history.',
      },
    },
    required: ['downloadUrl'],
    additionalProperties: true,
  };
}

function buildChildInterfaceSchema(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      state: {
        type: 'object',
        description: 'Snapshot of the child interface state.',
        additionalProperties: true,
      },
    },
    additionalProperties: true,
  };
}

function buildSchemaFallback(): JSONSchema7 {
  return {
    type: 'object',
    properties: {
      data: {
        type: 'object',
        description: 'Resolved schema payload exposed to the interface.',
        additionalProperties: true,
      },
    },
    additionalProperties: true,
  };
}
